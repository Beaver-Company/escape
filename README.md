# Escape 

Escape was written to solve common deployment woes. It was originially built to
support "Infrastructure as Code" platform delivery from start to finish, but
nowadays it can also be used to version, package and deploy documentation,
data, applications, or whatever you want really.

## Features

* Compose a platform out of versioned _units of deployments_
* Separate configuration from code
* Operations as code
* Work with multiple environments
* Easy to integrate into CI and CD processes
* Common release engineering tasks: optional automatic versioning, version
  control linking, packaging, uploading, downloading, templating

## Quickstart

At its core Escape provides abstractions to work with _units of deployments_. A
_unit of deployment_ is a collection of files, plus a bit of metadata to tell
Escape what can be done with it. Based on the metadata Escape knows how to
deploy, test and destroy the unit.

Metadata doesn't have to be written by hand, but can be compiled from an
_Escape plan_. The smallest Escape plan looks like this:

```
name: my-project/my-deployment-unit
version: 1.0
```

(Pro-tip: A documented, but otherwise fairly similar Escape plan, can be
generated by running `escape plan init -n my-deployment-unit`. You can also
format existing plans in this manner by running `escape plan fmt`)

The life cycle of almost every unit starts with a build step. This step is
generally only run on developer's workstations and CI servers. 

```
$ escape build
```

Our almost empty Escape plan doesn't define a build step however, 
but we can add one:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
```

Next we might wanna test our build:

```
$ escape test
```

And again we can define a field:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
```

Once a unit has been built we want to be able to deploy it into an
_environment_.

```
$ escape deploy
```

Same thing again. And let's also add a field for `escape smoke` to run our
smoke tests.


```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh
```

So far, so good. We're just running some tasks. Nothing fancy, but let's
package it all up into a distributable unit:

```
$ escape package
```

This takes all the files referenced in the Escape plan and adds them into an
archive, combined with the compiled metadata. We can include more files by glob
patterns:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh

includes:
- src/*.src
- assets/
- README

```

And then package again (we need to use the `-f` flag, because we already
created an archive for this version in the previous command)

```
$ escape package -f
```

Once happy we can push it to a server (note: the client points to the Ankyra
registry by default, which doesn't allow public writes, but you can run a
stand-alone registry)

```
$ escape push
```

This will make `my-project/my-deployment-unit-v1.0` available in the registry. Our fellow
engineers can now deploy this release by running:

```
$ escape deploy my-project/my-deployment-unit-v1.0
```

Instead of running all the steps one by one we can also use the `escape release` command, 
which is generally preferable in CI settings.


```
$ escape release
```

This will run the build, test, deploy, smoke, destroy, package and push steps
in succession to make sure the unit is working end-to-end.


A unit can depend on and inherit from other units.  A unit has inputs and outputs.
A unit can use its dependencies' outputs as its own inputs.
A unit can use its inputs as dependencies' inputs.
A unit can consume a provider

## Example releases

* https://github.com/ankyra/extension-kubespec
* https://github.com/ankyra/extension-packer
* https://github.com/ankyra/extension-terraform

All known public releases can be found in the registry: https://registry.ankyra.io/a/_/


## Installation

The easiest way to install Escape is to download the binaries from the website. 

### Build

This program can be build using standard Go tools. 

```
git clone https://github.com/ankyra/escape-client.git "$GOPATH/src/github.com/ankyra/escape-client"
go install
mv "$GOPATH/bin/escape-client" "$GOPATH/bin/escape"
```

## License

```
Copyright 2017 Ankyra

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
