# Escape 

Escape was written to solve common deployment woes. It was originially built to
support "Infrastructure as Code" platform delivery from start to finish, but
nowadays it can also be used to version, package and deploy documentation,
data, applications, or whatever you want really.

Its goal is to replace ad-hoc release engineering, deployment, orchestration
and operational systems with a cohesive model.

## Features

* Compose a platform out of versioned _units of deployment_
* Separate configuration from code
* Multi-environment
* Easy to integrate into CI and CD processes
* Common release engineering tasks: optional automatic versioning, version
  control linking, packaging, uploading, downloading, templating
* Operations as code
* Releases that work with Docker, Packer, Kubernetes, Terraform

## Installation

The easiest way to install Escape is to download the binaries from the website. 

### Build


```
git clone https://github.com/ankyra/escape-client.git "$GOPATH/src/github.com/ankyra/escape-client"
go install
mv "$GOPATH/bin/escape-client" "$GOPATH/bin/escape"
```

## Quickstart

At its core Escape provides abstractions to work with _units of deployments_. A
_unit of deployment_ is a collection of files, plus a bit of metadata to tell
Escape what can be done with it. Based on the metadata Escape knows how to
deploy, test and destroy the unit.

Metadata doesn't have to be written by hand, but can be compiled from an
_Escape plan_. The smallest Escape plan looks like this:

```
name: my-project/my-deployment-unit
version: 1.0
```

(Pro-tip: A documented, but otherwise fairly similar Escape plan, can be
generated by running `escape plan init -n my-deployment-unit`. You can also
format existing plans in this manner by running `escape plan fmt`)

### Build and test

The life cycle of almost every unit starts with a build step. This step is
generally only run on developer's workstations and CI servers. 

```
$ escape build
```

Our almost empty Escape plan doesn't define a build step however, 
but we can add one:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
```

Next we might wanna test our build:

```
$ escape test
```

And again we can define a field:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
```

### Deploy and smoke

Once a unit has been built we want to be able to deploy it into an
_environment_.

```
$ escape deploy
```

Same thing again. And let's also add a field for `escape smoke` to run our
smoke tests.


```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh
```


### Package

So far, so good. We're just running some tasks. Nothing fancy, but let's
package it all up into a distributable unit:

```
$ escape package
```

This takes all the files referenced in the Escape plan and adds them into an
archive, combined with the compiled metadata. We can include more files by glob
patterns:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh

includes:
- src/*.src
- assets/
- README

```

And then package again (we need to use the `-f` flag, because we already
created an archive for this version in the previous command)

```
$ escape package -f
```

### Push

Once happy we can push it to a server (note: the client points to the Ankyra
registry by default, which doesn't allow public writes, but you can run a
stand-alone registry).

```
$ escape push
```

This will make `my-project/my-deployment-unit-v1.0` available in the registry
and it will effectively freeze our version, because we can't upload the same
version twice. Our fellow engineers can now deploy this release by running:

```
$ escape deploy my-project/my-deployment-unit-v1.0
```

### Release

Instead of running all the steps one by one we can also use the `escape
release` command, which is generally preferable in CI settings.

```
$ escape release
```

This will run the build, test, deploy, smoke, destroy, package and push steps
in succession to make sure the unit is working end-to-end (although parts can
be skipped see `escape release --help`)

### Auto-versioning

It's a bit annoying to have to change the version field every time you do a
build, but at the same time having immutable releases is valuable. Wouldn't it
be nice if we could automatically pick a new version? Yes.

```
name: my-project/my-deployment-unit
version: 1.0.@
build: build_my_thing.sh
```

This will first build `1.0.0`, but once that's been released it will take
`1.0.1`, `1.0.2`, `1.0.3`, ...  If we want to work on a new minor version, we
can do change the field manually to:

```
name: my-project/my-deployment-unit
version: 1.1.@
build: build_my_thing.sh
```

And then the next version will be `1.1.0`, `1.1.1`, ... Following such a scheme
strikes a reasonable balance between having meaningful versions vs. an annoying
release process.

### Inputs and outputs

For more information on the scripting language see https://github.com/ankyra/escape-core/

### State management

### Errands

### Dependencies

A unit can use its dependencies' outputs as its own inputs.

### Providers and Consumers

A unit can consume a provider

### Extensions

### Templates

## Example releases

* https://github.com/ankyra/extension-kubespec
* https://github.com/ankyra/extension-packer
* https://github.com/ankyra/extension-terraform

All known public releases can be found in the registry: https://registry.ankyra.io/a/_/


## License

```
Copyright 2017 Ankyra

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
